{"version":3,"sources":["lib/fieldParsers.js","lib/Parser.js","lib/icsExporter.js","App.js","serviceWorker.js","index.js"],"names":["MonthNameDE","MonthNameDEDef","join","TimeDef","testDate","RegExp","DayDef","testTime","testTimeRange","testNotes","parseIfIsDate","ifElse","compose","test","prop","item","txt","parsed","exec","month","year","parseInt","forEach","def","index","replace","type","date","from","day","parseDate","body","parseIfIsTime","hour","minute","parseTime","parseIfIsTimeRange","to","parseTimeRange","parseIfIsNotes","notes","parseTitle","title","typeUndefCb","entry","cb","equals","Parser","this","events","defaults","parsedEntry","line","out","mergeDeepLeft","prefix","pick","push","parseLine","curry","s","a","t","i","e","length","c","charAt","splitter","map","trim","splitByComma","addType","value","data","parseDateTime","find","propEq","str","content","fm","attributes","url","filter","x","isEmpty","split","now","moment","icsExporter","properties","Property","name","uuid","v1","toDate","parameters","TZID","diff","add","VALUE","Component","icsEvent","components","toString","demoContent","App","useState","setContent","parser","parse","className","onClick","preventDefault","ics","blob","Blob","saveAs","onChange","target","event","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.cd0edf50.chunk.js","sourcesContent":["import { ifElse, compose, test, prop } from \"ramda\";\n\n// 01.01.1900 and 31.12.2099\n// https://stackoverflow.com/questions/12472976/regex-validate-european-date-format-with-multiple-separators\nconst DayDef = \"(3[01][.]?|[12][0-9][.]?|0[1-9][.]?|[1-9][.]?)\";\nconst MonthNumberDef = \"1[012][.]?|0[1-9][.]?|[1-9][.]?\";\n\nconst MonthNameDE = [\n  \"Januar|Jan.?\",\n  \"Februar|Febr.?|Feb.?\",\n  \"März|Mär.?|Marz|Mrz.?\",\n  \"April|Apr.?\",\n  \"Mai.?\",\n  \"Juni|Jun.?\",\n  \"Juli|Jul.?\",\n  \"August|Aug.?\",\n  \"September|Sept.?|Sep.?\",\n  \"Oktober|Okt.?\",\n  \"November|Nov.?\",\n  \"Dezember|Dez.?\"\n];\n\nconst MonthNameDEDef = MonthNameDE.join(\"|\");\nconst MonthDef = \"(\" + MonthNumberDef + \"|\" + MonthNameDEDef + \")\";\nconst DateDef = DayDef + \"[. ]*\" + MonthDef + \"[. ]*(19\\\\d\\\\d|20\\\\d\\\\d|\\\\d\\\\d)\";\n\n// h\nconst hourDef = \"([ ]*(h|uhr))*\";\n\n// 00:01 - 23:59\nconst TimeDef = \"([01]\\\\d|2[0-3]):?([0-5]\\\\d)?\" + hourDef;\n\n// to\nconst toDef = \"[ ]*([-–]|to|bis)[ ]*\";\n\nconst testDate = RegExp(\"^\" + DateDef + \"$\", \"i\");\nconst testTime = RegExp(\"^\" + TimeDef + \"$\", \"i\");\nconst testTimeRange = RegExp(\"^\" + TimeDef + toDef + TimeDef + \"$\", \"i\");\n\n// notes\nconst testNotes = /^(✏️|notes|note|Notes|Note)[:]?[ ]?(.*)/;\n\nconst parseDate = txt => {\n  let parsed = testDate.exec(txt);\n\n  let month = parsed[2];\n  let year = parseInt(parsed[3]);\n\n  // if the year is just in two digits assume we are speaking about 20??\n  if (year < 1900) {\n    year = year + 2000;\n  }\n\n  // parse names of month to month\n  MonthNameDE.forEach((def, index) => {\n    month = month.replace(RegExp(def, \"i\"), index + 1);\n  });\n\n  return {\n    type: \"date\",\n    date: {\n      from: {\n        day: parsed[1],\n        month: month,\n        year: year\n      }\n    }\n  };\n};\n\nconst parseNotes = txt => {\n  let parsed = testNotes.exec(txt);\n  return {\n    type: \"notes\",\n    notes: parsed[2]\n  };\n};\n\nconst parseTime = txt => {\n  let parsed = testTime.exec(txt);\n  return {\n    type: \"time\",\n    date: {\n      from: {\n        hour: parsed[1],\n        minute: parsed[2]\n      }\n    }\n  };\n};\n\nconst parseTimeRange = txt => {\n  let parsed = testTimeRange.exec(txt);\n  return {\n    type: \"time\",\n    date: {\n      from: {\n        hour: parsed[1],\n        minute: parsed[2]\n      },\n      to: {\n        hour: parsed[6],\n        minute: parsed[7]\n      }\n    }\n  };\n};\n\nexport const parseIfIsDate = ifElse(\n  compose(\n    test(testDate),\n    prop(\"body\")\n  ),\n  item => parseDate(item.body),\n  item => item\n);\n\nexport const parseIfIsTime = ifElse(\n  compose(\n    test(testTime),\n    prop(\"body\")\n  ),\n  item => parseTime(item.body),\n  item => item\n);\n\nexport const parseIfIsTimeRange = ifElse(\n  compose(\n    test(testTimeRange),\n    prop(\"body\")\n  ),\n  item => parseTimeRange(item.body),\n  item => item\n);\n\nexport const parseIfIsNotes = ifElse(\n  compose(\n    test(testNotes),\n    prop(\"body\")\n  ),\n  item => parseNotes(item.body),\n  item => item\n);\n\nexport const parseTitle = item => ({\n  type: \"title\",\n  title: { body: item.body },\n  body: item.body\n});\n","import fm from \"front-matter\";\nimport {\n  ifElse,\n  compose,\n  filter,\n  map,\n  trim,\n  isEmpty,\n  split,\n  equals,\n  prop,\n  propEq,\n  mergeDeepLeft,\n  find,\n  pick,\n  curry\n} from \"ramda\";\n\nimport {\n  parseIfIsDate,\n  parseIfIsTime,\n  parseIfIsTimeRange,\n  parseIfIsNotes,\n  parseTitle\n} from \"./fieldParsers\";\n\nconst typeUndefCb = (entry, cb) =>\n  ifElse(\n    compose(\n      equals(\"unknown\"),\n      prop(\"type\")\n    ),\n    item => cb(item),\n    item => item\n  )(entry);\n\nclass Parser {\n  constructor() {\n    this.events = [];\n  }\n\n  entry(entry, defaults) {\n    let parsedEntry = this.line(entry);\n    let out = mergeDeepLeft(parsedEntry, defaults);\n\n    out.date.to = mergeDeepLeft(out.date.to, out.date.from);\n\n    if (out.title.prefix && out.title.body) {\n      out.title = [out.title.prefix, out.title.body].join(out.title.join);\n    }\n\n    if (out.title.prefix && !out.title.body) {\n      out.title = out.title.prefix;\n    }\n\n    if (!out.title.prefix && (out.title.body || out.title.body === \"\")) {\n      out.title = out.title.body;\n    }\n\n    if (parsedEntry.notes && defaults.notes) {\n      out.notes = defaults.notes + \"\\n\" + parsedEntry.notes;\n    }\n\n    out = pick([\"date\", \"title\", \"notes\"], out);\n\n    this.events.push(out);\n    return out;\n  }\n\n  line(line) {\n    let out = line;\n\n    out = this.parseLine(out);\n    return out;\n  }\n\n  parseDateTime(item) {\n    // parse array\n    return compose(\n      curry(typeUndefCb(parseIfIsDate)),\n      curry(typeUndefCb(parseIfIsTime)),\n      curry(typeUndefCb(parseIfIsTimeRange)),\n      curry(typeUndefCb(parseIfIsNotes)),\n      curry(typeUndefCb(parseTitle))\n    )(item);\n  }\n\n  // see https://rosettacode.org/wiki/Tokenize_a_string_with_escaping#JavaScript\n  splitByComma(s) {\n    let esc = \"\\\\\";\n    let sep = \",\";\n    for (var a = [], t = \"\", i = 0, e = s.length; i < e; i += 1) {\n      var c = s.charAt(i);\n      if (c === esc) {\n        t += s.charAt(++i);\n      } else if (c !== sep) {\n        t += c;\n      } else {\n        a.push(t);\n        t = \"\";\n      }\n    }\n    a.push(t);\n    return a;\n  }\n\n  parseLine(line) {\n    // split up the line into components\n    // 30.4.2018, 18–20Uhr, Frühlingsferien => ['30.4.2018', '18–20Uhr', 'Frühlingsferien']\n    const splitter = compose(\n      map(trim),\n      this.splitByComma\n    );\n\n    // convert the string array to a object array\n    const addType = map(value => ({ type: \"unknown\", body: value }));\n\n    // build array\n    let data = compose(\n      addType,\n      splitter\n    )(line);\n\n    // parse array\n    data = map(this.parseDateTime, data);\n\n    let out = data;\n\n    out = mergeDeepLeft(\n      find(propEq(\"type\", \"time\"))(data) || {},\n      find(propEq(\"type\", \"date\"))(data) || {}\n    );\n\n    out = mergeDeepLeft(out, find(propEq(\"type\", \"notes\"))(data) || {});\n    out = mergeDeepLeft(out, find(propEq(\"type\", \"title\"))(data) || {});\n\n    return out;\n  }\n\n  parse(str) {\n    // parse frontmatter\n    var content = fm(str);\n\n    let _def = {\n      date: \"1.1.1970\",\n      title: \"event\",\n      url: \"\",\n      notes: \"\"\n    };\n\n    let defaults = mergeDeepLeft(content.attributes, _def);\n\n    if (defaults.date) {\n      defaults.date = this.parseDateTime({\n        type: \"unknown\",\n        body: defaults.date\n      }).date;\n    }\n\n    const splitter = compose(\n      filter(x => !isEmpty(x)),\n      map(trim),\n      split(/[\\r\\n]+/g /* here comes the line */)\n    );\n\n    let runLine = item => {\n      this.entry(item, defaults);\n    };\n    \n    map(runLine, splitter(content.body));\n  }\n}\n\nexport default Parser;\n","import moment from \"moment\";\nimport { Property, Component } from \"immutable-ics\";\nimport uuid from \"uuid\";\n\nconst now = new moment();\n\nclass icsExporter {\n  constructor(events) {\n    this.events = events || [];\n  }\n\n  // generate the icsEvent\n  icsEvent(data) {\n    let {\n      date: { from },\n      date: { to },\n      title,\n      url,\n      notes\n    } = data;\n    var properties = [];\n\n    properties.push(\n      new Property({\n        name: \"UID\",\n        value: uuid.v1()\n      }),\n      new Property({\n        name: \"DTSTAMP\",\n        value: now.toDate(),\n        parameters: {\n          // VALUE: 'DATE-TIME',\n          TZID: \"Europe/Zurich\"\n        }\n      }),\n      new Property({\n        name: \"SUMMARY\",\n        value: title || \"no Title\"\n      })\n    );\n\n    // zero based month in js\n    if (from.month) {\n      from.month = from.month - 1;\n    }\n\n    // zero based month in js\n    if (to.month) {\n      to.month = to.month - 1;\n    }\n\n    from = {\n      minute: from.minute || 0,\n      hour: from.hour || 0,\n      day: from.day || 1,\n      month: from.month || 0,\n      year: from.year || 1900\n    };\n\n    to = {\n      minute: to.minute || from.minute,\n      hour: to.hour || from.hour,\n      day: to.day || from.day,\n      month: to.month || from.month,\n      year: to.year || from.year\n    };\n\n    from = new moment(from);\n    to = new moment(to);\n\n    if (from.diff(to) === 0) {\n      // whole day handling\n      to.add(1, \"d\");\n      properties.push(\n        new Property({\n          name: \"DTSTART\",\n          value: from.toDate(),\n          parameters: {\n            // VALUE: 'DATE-TIME',\n            VALUE: \"DATE\"\n          }\n        }),\n        new Property({\n          name: \"DTEND\",\n          value: to.toDate(),\n          parameters: {\n            // VALUE: 'DATE-TIME',\n            VALUE: \"DATE\"\n          }\n        })\n      );\n    } else {\n      // handling with time\n      properties.push(\n        new Property({\n          name: \"DTSTART\",\n          value: from.toDate(),\n          parameters: {\n            // VALUE: 'DATE-TIME',\n            TZID: \"Europe/Zurich\"\n          }\n        }),\n        new Property({\n          name: \"DTEND\",\n          value: to.toDate(),\n          parameters: {\n            // VALUE: 'DATE-TIME',\n            TZID: \"Europe/Zurich\"\n          }\n        })\n      );\n    }\n\n    if (url) {\n      properties.push(\n        new Property({\n          name: \"URL\",\n          value: url,\n          parameters: {\n            VALUE: \"URI\"\n          }\n        })\n      );\n    }\n\n    if (notes) {\n      properties.push(\n        new Property({\n          name: \"DESCRIPTION\",\n          value: notes\n        })\n      );\n    }\n\n    var event = new Component({\n      name: \"VEVENT\",\n      properties\n    });\n\n    return event;\n  }\n\n  // generate the ics\n  ics() {\n    var events = [];\n\n    this.events.forEach(value => {\n      events.push(this.icsEvent(value));\n    });\n\n    const calendar = new Component({\n      name: \"VCALENDAR\",\n      components: events,\n      properties: [\n        new Property({\n          name: \"VERSION\",\n          value: 2\n        }),\n        new Property({\n          name: \"PRODID\",\n          value: \"signalwerk-generator\"\n        })\n      ]\n    });\n\n    let out = calendar.toString();\n    return out;\n  }\n}\n\nexport default icsExporter;\n","import React, { useState } from \"react\";\n\nimport Parser from \"./lib/Parser\";\nimport icsExporter from \"./lib/icsExporter\";\nimport { saveAs } from \"file-saver\";\n\nimport \"./App.css\";\n\nconst demoContent = `---\ntitle:\n  prefix: \"Meetup\"\n  join: \" – \"\ndate: 18:00–22:00\nnotes: bring beer.\n---\n22.2.2026, HTML\n29.2.2026, 16:00–17:00, JS, notes: it's nice`;\n\nfunction App() {\n  const [content, setContent] = useState(demoContent);\n  let parser = new Parser();\n\n  parser.parse(content);\n\n  // // Similar to componentDidMount and componentDidUpdate:\n  //  useEffect(() => {\n  //    // Update the document title using the browser API\n  //    document.title = `You clicked ${count} times`;\n  //  });\n  //\n  function handleClick(e) {\n    e.preventDefault();\n\n    let ics = new icsExporter(parser.events);\n    let out = ics.ics();\n\n    var blob = new Blob([out], { type: \"text/calendar;charset=utf-8\" });\n    saveAs(blob, \"events.ics\");\n  }\n\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        <h1>Events</h1>\n\n        {parser.events && parser.events.length > 0 && (\n          <button className=\"App-save\" onClick={handleClick}>\n            save .ics-file\n          </button>\n        )}\n        <textarea\n          className=\"App-input\"\n          value={content}\n          onChange={e => setContent(e.target.value)}\n        />\n        {parser.events &&\n          parser.events.length > 0 &&\n          parser.events.map(event => {\n            return (\n              <div className=\"App-event\">\n                <h3>{event.title}</h3>\n                <p>\n                  {event.date.from.day}\n                  {event.date.from.month}\n                  {event.date.from.year}\n                  {event.date.from.hour && event.date.from.minute && (\n                    <span>\n                      {\" \"}\n                      {event.date.from.hour}\n                      {\":\"}\n                      {event.date.from.minute}\n                    </span>\n                  )}\n                  {\" – \"}\n                  {event.date.to.day}\n                  {event.date.to.month}\n                  {event.date.to.year}\n                  {event.date.to.hour && event.date.to.minute && (\n                    <span>\n                      {\" \"}\n                      {event.date.to.hour}\n                      {\":\"}\n                      {event.date.to.minute}\n                    </span>\n                  )}\n                </p>\n                {event.notes && <p>{event.notes}</p>}\n              </div>\n            );\n          })}\n      </header>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}